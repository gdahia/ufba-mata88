\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[portuguese]{babel}
\usepackage{subfiles}
 
\title{Lista de Exercícios}
\author{Gabriel Dahia, Pedro Vidal}
 
\begin{document}
 
\maketitle
 
\begin{enumerate}

\item
    Um modelo de sistema distribuído é dito síncrono se existem aspectos do seu comportamento que dependem do compartilhamento, entre processos participantes, de uma mesma noção de tempo.
    Pela definição dada, existem inúmeras maneiras de sistemas apresentarem sincronia.
    Alguns exemplos disso são: o sistema saber o tempo máximo que um processo pode demorar para executar algo implica que os processos conhecem e concordam em um determinado momento específico para o início dessa execução; o sistema saber o tempo máximo que uma mensagem pode demorar para chegar a seu destinatário significa que os processos sabem em que momentos do passado não foram enviadas mensagens; os processos concordarem em um horário numérico significa que eles conhecem os relógios uns dos outros.
    
    Um modelo de sistema distribuído assíncrono, por sua vez, é tal que estas garantias temporais não existem.
    Trabalhar com modelos síncronos apresenta vantagens, já que é possível afirmar com certeza se um processo apresenta ou não alguns tipos de falhas ou se uma mensagem foi perdida ou não, por exemplo, mesmo que, pode-se argumentar, na prática, todos os sistemas distribuídos reais são assíncronos.

\item Ao iniciar o algoritmo, o processo inicial \textit{p} atribui lambda à \textit{pai[p]}, ou seja, inicialmente, o grafo trata-se de um grafo vazio (possui vértices mas não possui arestas), logo, o grafo não possui nenhum ciclo.

Durante a etapa de \textit{broadcast}, o processo \textit{p} manda uma mensagem \textit{m} para si mesmo, sem alterar o valor do atributo \textit{pai[p]}, portanto, o grafo não possui nenhum ciclo.

Ao receber uma mensagem de si mesmo, o processo \textit{p} terá como \textit{pai[p]} o valor \textit{p}, indicando que ele é o nó raíz. Ele irá enviar uma mensagem para todos os nós vizinhos \textit{v\textsubscript{i}}, que consequentemente executarão o \textit{deliver}, irão enviar a mensagem a seus vizinhos e irão alterar o valor de \textit{pai[\textit{v\textsubscript{i}}]} para \textit{p}. Portanto o grafo não possui nenhum ciclo.

Quando um processo \textit{p} recebe uma mensagem \textit{m} de um processo \textit{q}, ele irá verificar se já executou ou não \textit{deliver}. Caso ainda não tenha executado o \textit{deliver}, o processo \textit{p} irá enviar a mensagem \textit{m} para todos os processos vizinhos, irá executar o \textit{deliver} da mesagem \textit{m}, e irá alterar o valor de \textit{pai[p]} para \textit{q}. Caso ja tenha executado o \textit{deliver}, o processo \textit{p} não fará nada.

Após a etapa de \textit{deliver}, o grafo não possui nenhum ciclo, pois cada processo irá executar o \textit{deliver} apenas uma vez, ou seja, ele irá alterar o atributo \textit{pai[p]} apenas uma vez, e este irá apontar para o processo que enviou uma mensagem para ele, ou seja, o processo que `descobriu' ele. Portanto em nenhum momento, durante a execução ou ao final dela, o grafo possui ciclos. 

\item

\item

\item

\item

\item

\item

\item

\item

\end{enumerate}
 
\end{document}
