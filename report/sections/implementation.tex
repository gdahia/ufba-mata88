\documentclass[../main.tex]{subfiles}
 
\begin{document}

\subsection{Linguagem Java}

Além das considerações apresentadas anteriormente para escolha da linguagem de programação, a simplicidade para o tratamento de ações concorrentes em Java, também uma funcionalidade nativa da linguagem, tornou a implementação do trabalho muito mais fácil do que seria em alguma outra linguagem não tão apta a tarefa.
A versão anterior do projeto utilizava mecanismos de Java para o tratamento de concorrência (o uso da classe \textit{Vector} ao invés da mais comumente utilizada \textit{ArrayList}, por exemplo) que são pouco recomendados pela comunidade por falhas.
Isso foi corrigido com utilização de métodos \textit{synchronized} nos locais apropriados e problemas de concorrência devidos a má utilização dos recursos de Java não devem mais ser observados.

\subsection{Criando réplicas} \label{subsec:replicas}

Uma réplica, neste sistema, deve implementar a interface remota \textit{Server} - a única implementação fornecida é a classe \textit{ServerImpl}.

Para criar a primeira réplica, deve ser feita uma invocação da aplicação do servidor fornecendo o endereço IP (com o comando \textit{java ServerApp [endereço IP]}) no qual esta réplica deverá esperar para receber conexões.
Caso essa seja a única réplica criada, o sistema deverá se comportar exatamente quando o servidor era implementado de maneira centralizada.

Para criar uma réplica associada a um servidor previamente existente, deve ser feita invocação similar, fornecendo dois endereços IP: o endereço no qual esta réplica deverá esperar para receber comunicações (IP1) e o endereço para uma das réplicas do servidor ao qual se deseja integrar a nova réplica (IP2), com o comando \textit{java ServerApp [IP1] [IP2]}.

O funcionamento do sistema é baseado no conceito de comunicação em grupo.
Assim, o grupo precisa ter uma vision consistente de quais processos o integram.
Em outras palavras, o servidor precisa saber todas as réplicas que o compõem.
Isso é feito mantendo, em cada uma das réplicas, um \textit{ArrayList} de referências remotas para \textit{Server}s chamado \textit{replicas}.
Uma réplica é parte de um servidor exatamente quando há uma referência para si em \textit{replicas} de alguma outra réplica do servidor.
Como a vision do servidor é consistente entre réplicas, isso equivale a dizer que há referências para si em \textit{replicas} de todas as outras réplicas.
Se fóssemos modelar como um grafo a relação $R$, onde $aRb$ sse ``há referência de $a$ em \textit{replicas} de $b$'', teríamos um grafo direcionado completo sem laços.

Para fazer com que as réplicas concordem na vision do servidor, tratamos \textit{replicas} através das réplicas como um único recurso a ser compartilhado pelas réplicas, o qual chamamos \textbf{vision}.
Para garantir que a vision do servidor permaneça consistente mesmo com a adição de novas réplicas, utilizamos o algoritmo de exclusão mútua de Lamport \textit{et al.}~\cite{lamport-logical-clocks} para gerenciar o acesso à \textbf{vision}.

Argumentamos que a mudança, como apresentada na seção \ref{sec:model}, feita no modelo para o sistema - não é possível, inicialmente, que todos os processos se comuniquem, mas, ao invés disso, clientes fazem requisições às réplicas de maneira disjunta - mantém sua corretude: quando um processo $A$ deseja se tornar uma réplica, $A$ é um cliente fazendo uma requisição ao servidor através da réplica $B$.
Como as requisições para uma mesma réplica são feitas de maneira disjunta, podemos dizer que, no pior caso, cada réplica recebe uma requisição simultânea de um processo que deseja se tornar réplica.
Logo, os únicos processos que competem por \textbf{vision} são as réplicas do servidor, efetivamente fazendo com que todos os processos que competiram pelo recurso nesse momento sejam comunicáveis e reestabelecendo a corretude do algoritmo de exclusão mútua.
Uma réplica adicionada posteriormente precisará, para ter garantido acesso a \textbf{vision}, que receber mensagens posteriores de todas as outras réplicas; réplicas que já tivessem feito requisições de acesso a \textbf{vision} não serão afetadas pela entrada da nova réplica e suas futuras requisições necessariamente precisarão levar em conta a presença da nova réplica, cuja existência é agora conhecida por todos.

Mais detalhadamente, quando $A$ requer a $B$ sua entrada como réplica do servidor do qual $B$ faz parte, $B$ faz uma requisição, usando o protocolo do algoritmo de exclusão mútua, para ganhar acesso a \textbf{vision}.
Quando é garantido o acesso de $B$ a \textbf{vision}, $B$ faz com que cada outra réplica $C$ coloque uma referência a $A$ em seu respectiva \textit{replicas} e com que $A$ coloque uma referência a $C$ em seu \textit{replicas}.
Por fim, $B$ coloca uma referência a $A$ em seu \textit{replicas} e vice-versa, e $B$ libera \textbf{vision}.
Com isso, $A$ se torna uma réplica do servidor, pois em todas as outras réplicas há uma referência a $A$ e vice-versa.

\subsection{Conexão entre clientes e servidor}

É através da obtenção de uma referência a um objeto remoto que implementa a interface \textit{Server} (na prática, uma instância de \textit{ServerImpl}) que se dá a comunicação entre clientes e servidor.

A aplicação do cliente, implementada na classe \textit{ClientApp}, é responsável por obter a referência remota a uma réplica, dado o endereço IP como argumento da invocação, e instanciar a classe \textit{Client}, responsável pela interação com o usuário, com a instância obtida como argumento.

Qualquer réplica de um servidor pode ser conectada ao cliente.
A escolha de uma réplica determina que alguns recursos criados pelo cliente serão armazenados nessa réplica, mas, como visto posteriormente, não necessariamente.

\subsection{Registro de cadastros de usuários}

Os métodos \textit{addUser} e \textit{removeUser}, utilizados nesta versão e na anterior para, respectivamente, tentar de criar de um novo cadastro de usuário e deletar um cadastro de usuário, agora precisam deixar o registro de cadastros consistente entre as réplicas.
A abordagem utilizada é similar a gerência das réplicas do sistema, como visto na subseção \ref{subsec:replicas}.

Toda vez que um método (\textit{addUser}, \textit{removeUser}, \textit{getSession} ou \textit{addUserToChat}) que deseja acessar \textbf{sessions}, o registro de cadastro de usuários (um recurso compartilhado entre réplicas, assim como \textbf{vision}), é invocado, a réplica da invocação faz uma requisição para acessar não \textbf{sessions} propriamente, mas \textbf{vision}.

Não há problema em fazer essa requisição, pois as condições estabelecidas em \ref{sec:model} garantem que no momento em que o primeiro cliente fizer uma requisição, não haverá mais alteração em \textbf{vision}.
Usando o mesmo raciocínio visto em \ref{subsec:replicas}, vemos que as réplicas competem por \textbf{sessions} (indiretamente, ao competir por \textbf{vision}) podem se comunicar umas com as outras e as condições para o funcionamento do algoritmo de exclusão mútua são atendidas.

Assim, os métodos que leem ou modificam \textbf{sessions} primeiro pedem acesso ao recurso, fazem as operações desejadas no registro e depois o libera, garantindo a consistência do registro de cadastro de usuários.

Por exemplo, para criar um novo usuário, a réplica ao qual foi feita a requisição pede acesso a \textbf{vision}.
Quando lhe é garantido acesso a \textbf{vision}, sabemos que é a única réplica atualmente com acesso (por causa da corretude do algoritmo de exclusão mútua), e por isso podemos prosseguir sem nos preocuparmos com efeitos de concorrência.
É feita uma consulta se o nome de usuário requerido já está no cadastro.
Caso sim, o recurso é liberado e a requisição para criação do usuário é negada; caso contrário, o usuário é criado, uma referência remota a \textit{Session} correspondente, juntamente com as credenciais do usuário, são passadas a todas as outras réplicas, e o recurso é liberado.

\subsection{Localização de recursos}

\subsection{Outros recursos}

\end{document}
